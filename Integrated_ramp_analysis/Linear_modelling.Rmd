---
title: "Linear modelling for vr clusters"
author: "Harry Clark"
date: "19/04/2021"
output: html_document
---

## Fit linear models of position to firing rate

pull libraries and install dependencies if not done already
```{r}
# dependencies
# install.packages('reticulate')
# install.packages('dplyr')
# install.packages('broom')
# py_install("pandas")

library(dplyr)
library(broom)
library(reticulate)
```

1. Make function to run linear model
```{r}
lm_fit <- function(df) {
  if (length(df) == 1)
    return(NA)

  df <-
    tibble(
      Rates = as.numeric(Re(df$Rates)),
      Position = as.numeric(Re(df$Position)),
    )

  # fit the model
  df_fit <- lm(Rates ~ Position, data = df, na.action = na.exclude)

  # get the model parameters
  params <- select(glance(df_fit), r.squared, p.value)
  
  # get the coefficients
  coeffs <- tidy(df_fit)
  
  # combine the parameters and coefficients
  params$intercept <- coeffs$estimate[[1]]
  params$slope <- coeffs$estimate[[2]]
  return(params)
}
```


Function to get track positions for a given ramp region
```{r}
get_track_start <- function(track_region){
  if (track_region == "outbound"){
    track_start = 30
  } else if (track_region == "homebound") {
    track_start = 110
  } else if (track_region == "all") {
    track_start = 30
  } else {
    print("you have provided a track range not currently used in the analyis")
  }
  return(track_start)
}

get_track_end <- function(track_region){
  if (track_region == "outbound"){
    track_end = 90
  } else if (track_region == "homebound") {
    track_end = 170
  } else if (track_region == "all") {
    track_end = 170
  } else {
    print("you have provided a track range not currently used in the analyis")
  }
  return(track_end)
}
```


Function to compare the cluster slope vs the min and max from the shuffled rates
```{r}
compare_slopes <-
  function(min_slope, max_slope, slope, pval, p_thres) {
    if (any(is.na(list(min_slope, max_slope, slope, pval)))) {
      return("NAs")
    }
    if (pval > p_thres) {
      return("Unclassified")
    } else if (slope < min_slope & pval < p_thres) {
      return("Negative")
    } else if (slope > max_slope & pval < p_thres) {
      return("Positive")
    } else {
      return("Unclassified")
    }
  }
```


Function to extract the minimum and maximum slopes for the shuffled rates
```{r}

extract_min_shuffles_slope <- function(df){
  df <- tibble(slopes = unlist(df$slope))
  if (all(is.na(df$slopes))) {
    return(NA)
  }
  min_slope_o <- quantile(as.numeric(unlist(df$slopes)), c(.05, .95)) [[1]][1]
  return(min_slope_o)
}

extract_max_shuffles_slope <- function(df){
  df <- tibble(slopes = unlist(df$slope))
    if (all(is.na(df$slopes))) {
    return(NA)
  }
  max_slope_o <- quantile(as.numeric(unlist(df$slopes)), c(.05, .95)) [[2]][1]
  return(max_slope_o)
}

```


Function for running all data in space_binned_data and adding classifications to a classication dataframe
```{r, warning=FALSE}

process_data <- function(space_binned_data, classification_df, TT, track_region){
  print("procressing, TT= , track_region=")
  print(TT)
  print(track_region)
    
  # run for all session_ids and cluster ids within those sessions seperately
  session_ids = unique(space_binned_data$session_id)
  
  for (sess_id in session_ids) {
    
    # get data from a single session
    session_data <- subset(space_binned_data, session_id == sess_id)
    
    # get cluster ids from the session data
    cluster_ids = unique(session_data$cluster_id)
    
    # extract track position start and end points for the given track region
    track_region_start = get_track_start(track_region)
    track_region_end = get_track_end(track_region)
    
    for (id in cluster_ids) {
      # subset data for a givne cluster
      cluster_data <- subset(session_data, Position >= track_region_start & Position <= track_region_end &
                            Trial_Type == TT & Speeds > speed_threshold & cluster_id == id)
      
      # only run linear model if there was any trials of type TT for this cluster
      if (length(cluster_data$Rates)>1){
        
        # run linear mixed model
        lm_results <- lm_fit(cluster_data)
        intercept = lm_results$intercept
        slope = lm_results$slope
        
        # extract slopes from shuffle analysis
        shuffle_df <- shuffle_rates(cluster_data, shuffles=n_shuffles)
        min_slope <- extract_min_shuffles_slope(shuffle_df)
        max_slope <- extract_max_shuffles_slope(shuffle_df)

        # classify as a Negative, Positive of Unclassified sloping unit
        classification <- compare_slopes(min_slope, max_slope, lm_results$slope, lm_results$p.value, p_thres)
        
      } else {
        intercept = NaN
        slope = NaN
        classification = NaN
      }
      
      cluster_classification_df <- data.frame(cluster_id=c(id), session_id=c(sess_id), trial_type=c(TT), track_region=c(track_region),
                                              intercept=c(intercept), slope=c(slope), classification=c(classification))
      
      # add classifation to results df
      classification_df <- rbind(classification_df, cluster_classification_df)
    }
  }
  return(classification_df)
}
```


1. Function to generate shuffles
- shuffles spikes using sample() function
- runs lm
- extracts coefficients
- stores coefficients for each n shuffles (less memory than saving 100s of shuffles)
```{r}
# shuffles defines the number of shuffes. Use a smaller value for testing.
shuffle_rates <- function(df, shuffles=10) {
  
  # generate empty dataframe for storing shuffle slope and 
  shuffle_df <- data.frame(shuffle_i=integer(), intercept=double(), slope=double(), r_square=double(), p=double())
    
  for (i in 1:shuffles){
    shuff_df <- tibble(Rates = sample(as.vector(unlist(df$Rates)),replace = TRUE, prob = NULL), Position = as.numeric(Re(df$Position)))
    
    # fit the shuffled cluster data
    lm_results <- lm_fit(shuff_df)
    shuffle_i_df <- data.frame(shuffle_i=c(i), intercept=c(lm_results$intercept), 
                               slope=c(lm_results$slope), r_square=c(lm_results$r.squared), p=c(lm_results$p.value))
    
    # add the shuffle lm results to the lm results dataframe
    shuffle_df <- rbind(shuffle_df, shuffle_i_df)
  }

  return(shuffle_df)
}
```


1. load concatenated space binned data into R
```{r}
# set the working directory for loading the pickle reader (where this is)
setwd("C:/Users/44756/PycharmProjects/in_vivo_ephys_openephys/Edmond/Integrated_ramp_analysis/")
source_python("read_pickle.py")

# load the space binned data here
space_binned_data <- read_pickle_file("Z:/ActiveProjects/Harry/Ramp_cells_open_field_paper/space_binned_concatenated_spike_data.pkl")

# remove outliers
#TODO

p_thres = 0.01
speed_threshold = 3
n_shuffles = 1000
```


3. Run on all cells.
```{r, warning=FALSE}
# make an empty dataframe to store the classications in
classification_df <- data.frame(cluster_id=integer(), session_id=character(), trial_type=double(),
                                track_region=character(), intercept=double(), slope=double(), classification=character())

classification_df <- process_data(space_binned_data, classification_df, TT=0, track_region="outbound")
classification_df <- process_data(space_binned_data, classification_df, TT=1, track_region="outbound")
classification_df <- process_data(space_binned_data, classification_df, TT=2, track_region="outbound")
classification_df <- process_data(space_binned_data, classification_df, TT=0, track_region="homebound")
classification_df <- process_data(space_binned_data, classification_df, TT=1, track_region="homebound")
classification_df <- process_data(space_binned_data, classification_df, TT=2, track_region="homebound")
classification_df <- process_data(space_binned_data, classification_df, TT=0, track_region="all")
classification_df <- process_data(space_binned_data, classification_df, TT=1, track_region="all")
classification_df <- process_data(space_binned_data, classification_df, TT=2, track_region="all")
```

4. Save the classification dataframe in your save_path
```{r}
write.csv(classification_df,"Z:/ActiveProjects/Harry/Ramp_cells_open_field_paper/linear_model_classifations.csv", row.names = FALSE)
```

