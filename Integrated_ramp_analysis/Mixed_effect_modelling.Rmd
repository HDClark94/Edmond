---
title: "Mixed effect modelling for vr clusters"
output: html_notebook
---

---
title: "Mixed effect modelling for vr clusters"
author: "Harry Clark"
date: "16/04/2021"
output: html_document
---

## Fit mixed effect models to evaluate contributions of speed, acceleration and position to firing rate

Function to fit rates to position, speed and acceleration
```{r}
mm_fit <- function(df) {
  if (length(df) == 1)
    return(NA)
  
 df <-
    tibble(
      Rates = as.numeric(Re(df$Rates)),
      Position = as.numeric(Re(df$Position)),
      Acceleration = as.numeric(Re(df$Acceleration)),
      Speeds = as.numeric(Re(df$Speeds)),
      Trials = as.factor(df$Trials),
      Types = as.factor(df$Trial_Type)
    )
    
    df_int <-
    lme4::lmer(
      Rates ~ Position + Speeds + Acceleration + (1 + Position | Trials),
      data = df,
      na.action = na.exclude
    )
}
```

Function to extract P values for each coefficient from the model
```{r}
extract_mm_pvalues <- function(mm) {
  if (is.na(mm)) {
    return(tibble(pos = NA, speed = NA, accel = NA))
  }
    modelAnova <- car::Anova(mm)
    return_tibble <- tibble(pos = modelAnova$"Pr(>Chisq)"[[1]],
                  speed = modelAnova$"Pr(>Chisq)"[[2]],
                  accel = modelAnova$"Pr(>Chisq)"[[3]])
}

```

Function to categorise neurons based on significant model coefficients
```{r}

model_comparison <- function(mm_p, p_thres){
  null_pos = mm_p$pos
  null_speed = mm_p$speed
  null_accel = mm_p$accel
  
  if( is.na(null_pos) & is.na(null_accel)) {
    return( "None" )
  
  } else if( null_pos < p_thres & null_accel > p_thres & null_speed > p_thres) {
    return( "P" )
    
  } else if( null_pos > p_thres & null_accel > p_thres & null_speed < p_thres) {
    return( "S" ) 
    
  } else if( null_pos > p_thres & null_accel < p_thres & null_speed > p_thres) {
    return( "A" )
    
  } else if( null_pos < p_thres & null_accel > p_thres & null_speed < p_thres) {
    return("PS")
    
  } else if( null_pos < p_thres & null_accel < p_thres & null_speed > p_thres) {
    return( "PA" )
        
  } else if( null_pos > p_thres & null_accel < p_thres & null_speed < p_thres) {
    return("SA")

  } else if( null_pos < p_thres & null_accel < p_thres & null_speed < p_thres) {
    return("PSA")
    
  } else {
    return("None")
  }
}

```

Function to get track positions for a given ramp region
```{r}
get_track_start <- function(track_region){
  if (track_region == "outbound"){
    track_start = 30
  } else if (track_region == "homebound") {
    track_start = 110
  } else if (track_region == "all") {
    track_start = 30
  } else {
    print("you have provided a track range not currently used in the analyis")
  }
  return(track_start)
}

get_track_end <- function(track_region){
  if (track_region == "outbound"){
    track_end = 90
  } else if (track_region == "homebound") {
    track_end = 170
  } else if (track_region == "all") {
    track_end = 170
  } else {
    print("you have provided a track range not currently used in the analyis")
  }
  return(track_end)
}
```

Function for running all data in time_binned_data and adding classifications to a classication dataframe
```{r, warning=FALSE}

process_data <- function(time_binned_data, classification_df, TT, track_region){
    
  # run for all session_ids and cluster ids within those sessions seperately
  session_ids = unique(time_binned_data$session_id)
  
  for (session_id in session_ids) {
    
    # get data from a single session
    session_data <- subset(time_binned_data, session_id == session_id)
    
    # get cluster ids from the session data
    cluster_ids = unique(session_data$cluster_id)
    
    # extract track position start and end points for the given track region
    track_region_start = get_track_start(track_region)
    track_region_end = get_track_end(track_region)
    
    for (id in cluster_ids) {
      # subset data for a givne cluster
      cluster_data <- subset(session_data, Position >= track_region_start & Position <= track_region_end &
                            Trial_Type == TT & Speeds > speed_threshold & cluster_id == id)
      
      # only run mixed model if there was any trials of type TT for this cluster
      if (length(cluster_data$Rates)>1){
        
        # run linear mixed model
        mm_results <- mm_fit(cluster_data)
        
        # extract p values for position, speed and accelation
        mm_p <- extract_mm_pvalues(mm_results)
        
        # classify as P, S, A, PS, PA, SA or PSA
        cluster_classification <- model_comparison(mm_p, p_thres)
      } else {
        cluster_classification <- NaN
      }
      
      cluster_classification_df <- data.frame(cluster_id=c(id), session_id=c(session_id), trial_type=c(TT),
                                          track_region=c(track_region), classication=c(cluster_classification))
      
      # add classifation to results df
      classification_df <- rbind(classification_df, cluster_classification_df)
    }
  }
  return(classification_df)
}
```




1. load work space where concatenated time binned data is found and load data into R
```{r}
# set the working directory where the data is
setwd("Z:/ActiveProjects/Harry/Ramp_cells_open_field_paper/")

# load the time binned data here
time_binned_data = read.csv("time_binned_concatenated_spike_data.csv", header = TRUE)

# remove outliers
#TODO

speed_threshold = 3
p_thres = 0.01
```

2. Run on all cells.
Note here, there may be some overfitting with the mixed effect model. This is likely because some  coefficients likely do not vary with position. However, we can't address this by tailoring the model to each cell as we want to treat each cell the same way. The standardized coefficients should still be interpretable.
See discussion in ?isSingular and here: https://stats.stackexchange.com/questions/378939/dealing-with-singular-fit-in-mixed-models
```{r, warning=FALSE}
# make an empty dataframe to store the classications in
classification_df <- data.frame(cluster_id=integer(), session_id=character(), trial_type=integer(),
                                track_region=character(), classication=character())

classification_df <- process_data(time_binned_data, classification_df, TT=0, track_region="outbound")
classification_df <- process_data(time_binned_data, classification_df, TT=1, track_region="outbound")
classification_df <- process_data(time_binned_data, classification_df, TT=2, track_region="outbound")
classification_df <- process_data(time_binned_data, classification_df, TT=0, track_region="homebound")
classification_df <- process_data(time_binned_data, classification_df, TT=1, track_region="homebound")
classification_df <- process_data(time_binned_data, classification_df, TT=2, track_region="homebound")
classification_df <- process_data(time_binned_data, classification_df, TT=0, track_region="all")
classification_df <- process_data(time_binned_data, classification_df, TT=1, track_region="all")
classification_df <- process_data(time_binned_data, classification_df, TT=2, track_region="all")
```

3. Save the classification dataframe in your save_path
```{r}
write.csv(classification_df,"Z:/ActiveProjects/Harry/Ramp_cells_open_field_paper/mixed_model_classifations.csv", row.names = FALSE)
```






